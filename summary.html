<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Summary</title>
    <style type="text/css">
table {
	width: 100%;
	margin-bottom: 20px;
	border: 1px solid #dddddd;
	border-collapse: collapse;
}
th {
	font-weight: bold;
	color:white;
	padding: 5px;
	background: gray;
	border: 1px solid gray;
}
td{
	border: 1px solid #dddddd;
	padding: 5px;
}
td:first-child{width:25%; padding-left:15pt}
td[colspan="2"]{background-color:#efefef;font-weight:bold;}
    </style>
</head>
<body>
	<h1>Паттерны и примеры из книги!!!</h1>
<table>
    <thead>
    <tr><th>Паттерн</th><th>Аспекты, которые можно изменять</th></tr>
    </thead>
    <tbody>
    <tr><td colspan="2">Порождающие паттерны</td></tr>
    <tr><td><a href="img/abstract_factory.svg">Абстрактная фабрика</a></td>
        <td>Семейства порождаемых объектов</td>
    </tr>
    <tr><td><a href="img/singleton.svg">Одиночка</a></td>
        <td>Единственный экземпляр класса</td>
    </tr>
    <tr><td><a href="img/prototype.svg">Прототип</a></td>
        <td>Класс, из которого инстанцируется объект
        <p>У вас есть объект, который нужно скопировать. Как это сделать?
Нужно создать пустой объект такого же класса,
а затем поочерёдно скопировать значения всех полей из старого объекта в новый.
<p>Прекрасно! Но есть нюанс. Не каждый объект удастся скопировать таким образом,
ведь часть его состояния может быть приватной,
 а значит – недоступной для остального кода программы.
<p>Но есть и другая проблема. Копирующий код станет зависим от классов копируемых объектов.
 Ведь, чтобы перебрать все поля объекта, нужно привязаться к его классу.
 Из-за этого вы не сможете копировать объекты, зная только их интерфейсы, а не конкретные классы.
<p>Решение: Паттерн Прототип поручает создание копий самим копируемым объектам.
Он вводит общий интерфейс для всех объектов, поддерживающих клонирование.
 Это позволяет копировать объекты, не привязываясь к их конкретным классам.
 Обычно такой интерфейс имеет всего один метод clone.
<p>Реализация этого метода в разных классах очень схожа.
Метод создаёт новый объект текущего класса и копирует в него
значения всех полей собственного объекта.
Так получится скопировать даже приватные поля,
так как большинство языков программирования разрешает
доступ к приватным полям любого объекта текущего класса.
<p>Объект, который копируют, называется прототипом
(откуда и название паттерна). Когда объекты программы содержат сотни полей
и тысячи возможных конфигураций, прототипы могут служить
своеобразной альтернативой созданию подклассов.
<a href="https://radioprog.ru/post/1467">ссылка</a></td>
    </tr>
    <tr><td><a href="img/builder.svg">Строитель</a></td>
        <td>Способ создания составного объекта. <p>- Когда процесс создания нового объекта не должен зависеть от того,
из каких частей этот объект состоит и как эти части связаны между собой
<p>- Когда необходимо обеспечить получение различных вариаций объекта в процессе его создания
<a href="https://metanit.com/sharp/patterns/2.5.php">ссылка</a>
<p>В отличие от фабрики акцент на пошаговом создании объекта, а в фабрике - на семействе объектов
<p>Нет абстрактного описания получаемого продукта - клиент знает, какой продукт заказывает и как с ним
обращаться. Продукты могут быть очень разными.</td>
    </tr>
    <tr><td><a href="img/fabric_method.svg">Фабричный метод</a></td>
        <td>Инстанцируемый подкласс объекта</td>
    </tr>
    <tr><td colspan="2">Структурные паттерны</td></tr>
    <tr><td><a href="img/adapter.svg">Адаптер</a></td>
        <td>Интерфейс к объекту
        <p>Преобразует интерфейс одного класса в интерфейс другого, который ожидают клиенты
Обеспечивает совместную работу классов, которая без него была бы невозможна</p></td>
    </tr>
    <tr><td><a href="img/decorator.svg">Декоратор</a></td>
        <td>Обязанности объекта без порождения подкласса</td>
    </tr>
    <tr><td><a href="img/proxy.svg">Заместитель</a></td>
        <td>Способ доступа к объекту, его местоположение
        Когда надо осуществлять взаимодействие по сети, а объект-проси должен имитировать поведения
объекта в другом адресном пространстве. Использование прокси позволяет снизить
накладные издержки при передачи данных через сеть.
Подобная ситуация еще называется удалённый заместитель (remote proxies)
<p>
Когда нужно управлять доступом к ресурсу, создание которого требует больших затрат.
Реальный объект создается только тогда, когда он действительно может понадобится,
а до этого все запросы к нему обрабатывает прокси-объект.
Подобная ситуация еще называется виртуальный заместитель (virtual proxies)
<p>
Когда необходимо разграничить доступ к вызываемому объекту в зависимости
от прав вызывающего объекта. Подобная ситуация еще называется
защищающий заместитель (protection proxies)
<p>
Когда нужно вести подсчет ссылок на объект или обеспечить
потокобезопасную работу с реальным объектом.
Подобная ситуация называется "умные ссылки" (smart reference)
</td>
    </tr>
    <tr><td><a href="img/composite.svg">Компоновщик</a></td>
        <td>Структура и состав объекта</td>
    </tr>
    <tr><td><a href="img/bridge.svg">Мост</a></td>
        <td>Реализация объекта
        <p>Связь агрегации между классами Abstraction и Implementor фактически
и представляет некоторый мост между двумя параллельными иерархиями классов.</p></td>
    </tr>
    <tr><td><a href="img/flyweight.svg" >Приспособленец</a></td>
        <td>Накладные расходы на хранение объекта
        <p>Хранит в себе пул уже существующих объектов - приспособленцев (может быть сгенерирован заранее)
и по запросу выдает существующий, а не генерит новый объект</p></td>
    </tr>
    <tr><td><a href="img/facade.svg">Фасад</a></td>
        <td>Интерфейс к подсистеме
        <ul><li>класс, организующий работу с разветвленной подсистемой(например, с компилятором)</li>
<li>класс знает каким подсистемам адресовать запрос</li>
<li>Классы подсистемы реализуют функциональность подсистемы,
            ничего не знают о существовании фасада, не хранят ссылок на него</li></ul>
        </td>
    </tr>
    <tr><td colspan="2">Паттерны поведения</td></tr>
    <tr><td><a href="img/interpreter.svg">Интерпретатор</a></td>
        <td>Грамматика и интерпретация языка
        <p>для заданного языка определяет представление его грамматики, а также
интерпретатор предложений этого языка
Предложение этого языка можно представить в виде абстрактного синтаксического дерева.</td>
    </tr>
    <tr><td><a href="img/iterator.svg"> Итератор</a></td>
        <td>Способ обхода элементов агрегата. Когда необходимо менять итераторы, не забираясь в код конкретного списка(итерируемого объекта)</td>
    </tr>
    <tr><td><a href="img/command.svg">Команда</a></td>
        <td>Время и способ выполнения запроса
        <p>Инкапсулирует запрос как объект, позволяя тем самым задавать параметры клиентов для обработки
соответствующих запросов, ставить запросы в очередь или протоколировать их,
а также поддерживать отмену операций.
<p>Например - кнопки и меню не знают, кто будет обрабатывать их запросы. В реализации кнопок и меню
нет действий, которые они должны инициировать.
<p>Команда может состоять из нескольких команд, направленных в разные места. Тогда нужен класс
MacroCommand, реализующий последовательность команда Command.</td>
    </tr>
    <tr><td><a href="img/observer.svg">Наблюдатель</a></td>
        <td>Множество объектов, зависящих от другого объекта; способ, которым зависимые
        объекты поддерживают себя в актуальном состоянии
        <p>К данным прикреплены диаграмма и таблица. Они не знают друг о друге, но когда пользователь
работает с таблицей, то изменений отражаются и на диаграмме, и наоборот.
И таблица, и диаграмма зависят от данных объекта и поэтому должны уведомляться о любы изменениях
в его состоянии.
<p>Субъект - может быть сколько угодно зависимых от него наблюдателей.
Все наблюдатели уведомляются об изменениях в состоянии субъекта. Получив уведомление,
наблюдатель опрашивает субъекта, чтобы синхронизировать с ним свой состояние.
<p>Субъект не имеет информации о том, какие объекты являются подписчиками.</p></td>
    </tr>
    <tr><td><a href="img/visitor.svg">Посетитель</a></td>
        <td>Операции, которые можно применить к объекту или объектам, не меняя класса
        <p>описывает операцию с каждым объектом из некоторой структуры. Позволяет определить новую операцию,
не изменяя классы этих объектов.
<p>Выполняемые операции зависят и от типа посещаемого объекта, и от типа посетителя.</p>
        </td>
    </tr>
    <tr><td><a href="img/mediator.svg">Посредник</a>  <a href="img/mediator2.svg">2</a> </td>
        <td>Объекты, взаимодействующие между собой, и способ их коопераций
            <ul><li>определяет объект, инкапсулирующий способ взаимодействия множества объектов.</li>
<li>Посредник обеспечивает слабую связанность системы, избавляя объекты
от необходимости явно ссылаться друг на друга и позволяя тем самым независимо
    изменять взаимодействия между ними.</li></ul>
        </td>
    </tr>
    <tr><td><a href="img/state.svg" >Состояние</a></td>
        <td>Состояние объекта
        <p>позволяет объекту варьировать свое поведение в зависимости от внутреннего состояния.
Извне создается впечатление, что изменился класс объекта.
<p>
Применяется, когда в коде операций встречаются состоящие из многих ветвей условные
операторы, в которых выбор ветви зависит от состояния.</p></td>
    </tr>
    <tr><td><a href="img/strategy.svg">Стратегия</a></td>
        <td>Алгоритм
        <p>определяет семейство алгоритмов, инкапсулирует их и делает их взаимонезависимыми.
Стратегия позволяет изменять алгоритмы независимо от клиентов, которые ими пользуются.

<p>При этом конкретные стратегии могут пользоваться не всей информацией, которую им передает Контекст.
Интерфейс Контекста должен быть спроектирован, чтобы покрыть все возможные потребности стратегий,
которые могут добавляться в будущем. Также должен быть спроектирован интерфейс
абстрактного класса Strategy
        </td>
    </tr>
    <tr><td>Хранитель</td>
        <td>Закрытая информация, хранящаяся вне объекта, и время ее сохранения
        <p>не нарушая инкапсуляции фиксирует и выносит за пределы объекта его внутреннее состояние так,
чтобы позднее можно было восстановить в нем обьект</p></td>
    </tr>
    <tr><td><a href="chain.svg">Цепочка обязанностей</a> <a href="img/chain2.svg">(2)</a></td>
        <td>Объект, выполняющий запрос
<p>
Есть более одного объекта, способного обработать запрос, причем настоящий обработчик заранее не известен
Нужно отправить запрос одному из обработчиков, причем заранее не известно, кому именно
Набор объектов, способных обработать запрос, изменяется динамически.
https://www.geeksforgeeks.org/chain-of-responsibility-python-design-patterns/</td>
    </tr>
    <tr><td>Шаблонный метод</td>
        <td>Шаги алгоритма</td>
    </tr>
    </tbody>
</table>
</body>
</html>
